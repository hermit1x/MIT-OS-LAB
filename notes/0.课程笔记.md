## Lecture 1

每个进程有自己的fd空间

在riscv中使用e-call的汇编使用内核态指令（类似 init 中断？）

```exac()```会接管进程

在linux中想要使用```exax()```但继续运行程序会使用```fork()```让子进程去执行

```fork()```会复制所有的堆、栈、寄存器（尊嘟复制），从```fork()```的下一句开始执行

```pid = fork()```，父进程的pid会是系统的pid，子进程的pid=0

```exac()```在出错的时候会将控制权返回调用它的函数。

```wait(&status)```父进程等待子进程（其中之一）结束，可以多```wait()```几次，返回child id

不在乎返回值的时候可以```wait(0)```

没有办法让子进程等待父进程

child更改fd是常用的重定向输出方法

调用一个程序的时候```arg1```往往是程序自己的名字

```close(fd)```会释放一个fd，新的fd总是从最小的可用的fd开始

```new_fd = dup(fd)```分配一个新的fd，和上一个fd指向一个地方，共享buffer

```link("a", "b")```创建a的一个名为b的链接```unlink()```取消链接

当某一个文件的链接数为0、且没有fd连接到它时，会被系统回收


